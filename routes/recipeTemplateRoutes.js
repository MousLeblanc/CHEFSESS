// routes/recipeTemplateRoutes.js
import express from 'express';
import RecipeTemplate from '../models/RecipeTemplate.js';
import RecipeComponent from '../models/RecipeComponent.js';
import { protect } from '../middleware/authMiddleware.js';
import asyncHandler from 'express-async-handler';

const router = express.Router();

// @desc    Créer un template de recette combinée
// @route   POST /api/recipe-templates
// @access  Private
router.post('/', protect, asyncHandler(async (req, res) => {
  const { protein, sauce, accompaniment, garnish, mealType, defaultServings } = req.body;
  
  // Vérifier que la protéine existe
  const proteinComponent = await RecipeComponent.findById(protein);
  if (!proteinComponent || proteinComponent.type !== 'protein') {
    res.status(400);
    throw new Error('Protéine invalide');
  }
  
  // Vérifier les compatibilités si sauce/accompagnement fournis
  if (sauce) {
    const sauceComponent = await RecipeComponent.findById(sauce);
    if (!sauceComponent || sauceComponent.type !== 'sauce') {
      res.status(400);
      throw new Error('Sauce invalide');
    }
    if (!sauceComponent.compatibleWith.proteins.includes(protein)) {
      res.status(400);
      throw new Error('Sauce non compatible avec cette protéine');
    }
  }
  
  if (accompaniment) {
    const accompanimentComponent = await RecipeComponent.findById(accompaniment);
    if (!accompanimentComponent || accompanimentComponent.type !== 'accompaniment') {
      res.status(400);
      throw new Error('Accompagnement invalide');
    }
    if (!accompanimentComponent.compatibleWith.proteins.includes(protein)) {
      res.status(400);
      throw new Error('Accompagnement non compatible avec cette protéine');
    }
  }
  
  if (garnish) {
    const garnishComponent = await RecipeComponent.findById(garnish);
    if (!garnishComponent || garnishComponent.type !== 'garnish') {
      res.status(400);
      throw new Error('Garnish invalide');
    }
  }
  
  const template = new RecipeTemplate({
    protein,
    sauce,
    accompaniment,
    garnish,
    mealType: mealType || 'déjeuner',
    defaultServings: defaultServings || 4,
    createdBy: req.user._id
  });
  
  // Populate pour calculer les totaux
  await template.populate(['protein', 'sauce', 'accompaniment', 'garnish']);
  await template.save();
  
  // Re-populate pour retourner les données complètes
  await template.populate(['protein', 'sauce', 'accompaniment', 'garnish']);
  
  res.status(201).json({
    success: true,
    data: template
  });
}));

// @desc    Récupérer tous les templates avec filtres
// @route   GET /api/recipe-templates
// @access  Private
router.get('/', protect, asyncHandler(async (req, res) => {
  const {
    protein,
    mealType,
    allergens,
    dietaryRestrictions,
    isAutoGenerated,
    tags, // Tags pour filtrer
    limit = 50,
    skip = 0
  } = req.query;
  
  let filter = {};
  
  if (protein) {
    filter.protein = protein;
  }
  
  if (mealType) {
    filter.mealType = mealType;
  }
  
  if (allergens) {
    const allergensList = Array.isArray(allergens) ? allergens : allergens.split(',');
    filter.allergens = { $nin: allergensList };
  }
  
  if (dietaryRestrictions) {
    const restrictionsList = Array.isArray(dietaryRestrictions) 
      ? dietaryRestrictions 
      : dietaryRestrictions.split(',');
    filter.$or = [
      { dietaryRestrictions: { $in: restrictionsList } },
      { dietaryRestrictions: { $size: 0 } }
    ];
  }
  
  if (isAutoGenerated !== undefined) {
    filter.isAutoGenerated = isAutoGenerated === 'true';
  }
  
  // Filtrer par tags
  if (tags) {
    const tagsList = Array.isArray(tags) ? tags : tags.split(',').map(t => t.trim().toLowerCase());
    filter.tags = { $in: tagsList };
  }
  
  const templates = await RecipeTemplate.find(filter)
    .populate('protein')
    .populate('sauce')
    .populate('accompaniment')
    .populate('garnish')
    .limit(parseInt(limit))
    .skip(parseInt(skip))
    .sort({ createdAt: -1 });
  
  res.json({
    success: true,
    count: templates.length,
    data: templates
  });
}));

// @desc    Récupérer un template par ID
// @route   GET /api/recipe-templates/:id
// @access  Private
router.get('/:id', protect, asyncHandler(async (req, res) => {
  const template = await RecipeTemplate.findById(req.params.id)
    .populate('protein')
    .populate('sauce')
    .populate('accompaniment')
    .populate('garnish');
  
  if (!template) {
    res.status(404);
    throw new Error('Template non trouvé');
  }
  
  res.json({
    success: true,
    data: template
  });
}));

// @desc    Mettre à jour un template
// @route   PUT /api/recipe-templates/:id
// @access  Private
router.put('/:id', protect, asyncHandler(async (req, res) => {
  const template = await RecipeTemplate.findById(req.params.id);
  
  if (!template) {
    res.status(404);
    throw new Error('Template non trouvé');
  }
  
  // Mettre à jour les champs
  Object.keys(req.body).forEach(key => {
    if (key !== '_id' && key !== 'createdAt' && key !== 'totalNutrition' && key !== 'totalIngredients') {
      template[key] = req.body[key];
    }
  });
  
  // Re-populate et sauvegarder pour recalculer les totaux
  await template.populate(['protein', 'sauce', 'accompaniment', 'garnish']);
  const updatedTemplate = await template.save();
  
  await updatedTemplate.populate(['protein', 'sauce', 'accompaniment', 'garnish']);
  
  res.json({
    success: true,
    data: updatedTemplate
  });
}));

// @desc    Supprimer un template
// @route   DELETE /api/recipe-templates/:id
// @access  Private
router.delete('/:id', protect, asyncHandler(async (req, res) => {
  const template = await RecipeTemplate.findById(req.params.id);
  
  if (!template) {
    res.status(404);
    throw new Error('Template non trouvé');
  }
  
  await template.deleteOne();
  
  res.json({
    success: true,
    message: 'Template supprimé'
  });
}));

// @desc    Obtenir les ingrédients pour un nombre de personnes spécifique
// @route   GET /api/recipe-templates/:id/ingredients/:servings
// @access  Private
router.get('/:id/ingredients/:servings', protect, asyncHandler(async (req, res) => {
  const template = await RecipeTemplate.findById(req.params.id);
  
  if (!template) {
    res.status(404);
    throw new Error('Template non trouvé');
  }
  
  const servings = parseInt(req.params.servings) || template.defaultServings;
  const ingredients = template.getIngredientsForServings(servings);
  
  res.json({
    success: true,
    servings,
    data: ingredients
  });
}));

export default router;

