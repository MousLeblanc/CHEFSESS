import os
import sys
import json
import time
from openai import OpenAI

# ------------------------------------------------------------------
# CONFIG
# ------------------------------------------------------------------
MODEL = "gpt-4o-mini"   # tu peux mettre "gpt-4.1" ou "gpt-5.1" si tu veux
SLEEP_BETWEEN_CALLS = 0.2  # petite pause entre les requÃªtes

client = OpenAI(
    api_key=os.environ.get("OPENAI_API_KEY")
)

SYSTEM_PROMPT = """
Tu es un assistant culinaire pour une application de restauration collective franÃ§aise.
On te donne **UNE** recette au format JSON (schÃ©ma Chef SES).

Tu dois renvoyer EXACTEMENT le mÃªme JSON, mais en appliquant les rÃ¨gles suivantes :

1. LANGUE
   - Tous les champs textuels doivent Ãªtre en FRANÃ‡AIS :
     - name
     - description
     - ingredients[i].name
     - preparationSteps[i]
     - category, hashtags, tags, diet, pathologies (quand ce sont des chaÃ®nes)
   - Si un texte est dÃ©jÃ  en franÃ§ais : corrige lâ€™orthographe et amÃ©liore lÃ©gÃ¨rement le style si nÃ©cessaire.

2. UNITÃ‰S
   - Convertis les unitÃ©s de cuisine anglo-saxonnes en unitÃ©s mÃ©triques franÃ§aises.
   - Exemples :
       * tsp, teaspoon  â†’ c. Ã  cafÃ© (~5 ml)
       * tbsp, tablespoon â†’ c. Ã  soupe (~15 ml)
       * cup â†’ gÃ©nÃ©ralement 240 ml (liquides) ou 120â€“140 g (secs, adapte selon lâ€™ingrÃ©dient)
       * oz (fluid ounce) â†’ ~30 ml
       * oz (poids) â†’ ~28 g
       * lb â†’ ~450 g
   - Utilise uniquement : g, kg, ml, cl, dl, L, c. Ã  cafÃ©, c. Ã  soupe, piÃ¨ce(s).
   - Ajuste les QUANTITÃ‰S en consÃ©quence, avec des valeurs rÃ©alistes (arrondies pour la cuisine).
   - Si lâ€™unitÃ© est dÃ©jÃ  mÃ©trique correcte (g, ml, cl, L, etc.), garde-la mais corrige si besoin (par ex. "gr" â†’ "g").

3. ORTHOGRAPHE & STYLE
   - Corrige les fautes dâ€™orthographe et de grammaire en franÃ§ais.
   - Garde un style simple, clair, adaptÃ© Ã  une fiche technique de cuisine de collectivitÃ©.
   - Ne change pas le sens des recettes.

4. STRUCTURE
   - NE CHANGE PAS la structure JSON :
       * Ne supprime pas de clÃ©s existantes.
       * Ne rajoute pas de nouvelles clÃ©s.
       * Laisse tous les champs non textuels intacts (id, quantitÃ©s numÃ©riques, nutriments, Ã¢ge, etc.) SAUF les unitÃ©s et quantitÃ©s que tu dois adapter aux conversions.
   - Si un champ nâ€™est pas concernÃ©, laisse-le tel quel.

5. SORTIE
   - RÃ©ponds UNIQUEMENT par un JSON valide.
   - PAS de texte explicatif, PAS de Markdown, PAS de commentaires, juste lâ€™objet JSON.
"""

def process_recipe(recipe: dict, index: int, total: int, target_lang: str = "fr") -> dict:
    """
    Envoie UNE recette au modÃ¨le OpenAI, rÃ©cupÃ¨re la recette traduite/nettoyÃ©e.
    """
    print(f"\n=== Recette {index+1}/{total} ===")
    name = recipe.get("name", "(sans nom)")
    print("   Nom original :", name[:80])

    # On envoie la recette telle quelle au modÃ¨le
    user_prompt = (
        "Voici une recette au format JSON. "
        "Applique toutes les rÃ¨gles dÃ©crites dans le message systÃ¨me et renvoie UNIQUEMENT le JSON transformÃ©.\n\n"
        + json.dumps(recipe, ensure_ascii=False, indent=2)
    )

    try:
        response = client.chat.completions.create(
            model=MODEL,
            messages=[
                {"role": "system", "content": SYSTEM_PROMPT},
                {"role": "user", "content": user_prompt},
            ],
            temperature=0.2,
        )
        content = response.choices[0].message.content.strip()
        # Debug Ã©ventuel :
        # print(content)

        # On essaye de parser le JSON retournÃ©
        new_recipe = json.loads(content)
        print("   âœ… Recette traitÃ©e avec succÃ¨s.")
        return new_recipe

    except Exception as e:
        print("   âš ï¸ Erreur sur cette recette, on garde lâ€™originale. DÃ©tail :", str(e))
        return recipe


def main():
    if len(sys.argv) < 3:
        print("Usage : python translate_recipes_openai.py <input_json> fr")
        sys.exit(1)

    input_file = sys.argv[1]
    target_lang = sys.argv[2]

    if not os.path.exists(input_file):
        print("Fichier introuvable :", input_file)
        sys.exit(1)

    print("ğŸ“‚ Chargement du fichier :", input_file)
    with open(input_file, "r", encoding="utf-8") as f:
        data = json.load(f)

    if not isinstance(data, list):
        print("Le fichier ne contient pas une liste de recettes JSON.")
        sys.exit(1)

    total = len(data)
    print(f"ğŸ”„ Nombre de recettes Ã  traiter : {total}")

    output = []
    for i, recipe in enumerate(data):
        new_recipe = process_recipe(recipe, i, total, target_lang)
        output.append(new_recipe)

        # Sauvegarde de secours tous les 50 pour ne rien perdre
        if (i + 1) % 50 == 0:
            backup_file = f"translated_partial_{target_lang}_{i+1}.json"
            with open(backup_file, "w", encoding="utf-8") as bf:
                json.dump(output, bf, ensure_ascii=False, indent=2)
            print(f"   ğŸ’¾ Sauvegarde intermÃ©diaire : {backup_file}")

        time.sleep(SLEEP_BETWEEN_CALLS)

    output_file = f"translated_openai_{target_lang}.json"
    print("\nğŸ’¾ Enregistrement final dans :", output_file)
    with open(output_file, "w", encoding="utf-8") as out:
        json.dump(output, out, ensure_ascii=False, indent=2)

    print("\nâœ… TRAVAIL TERMINÃ‰ !")


if __name__ == "__main__":
    main()
