import mongoose from "mongoose";

const recipeTemplateSchema = new mongoose.Schema({
  name: { type: String, required: true }, // Généré automatiquement : "Cuisse de poulet + Sauce champignons + Riz"
  
  // Composants
  protein: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'RecipeComponent',
    required: true 
  },
  sauce: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'RecipeComponent' 
  }, // Optionnel
  accompaniment: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'RecipeComponent' 
  }, // Optionnel
  garnish: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'RecipeComponent' 
  }, // Optionnel
  
  // Instructions combinées (générées automatiquement)
  combinedInstructions: [String],
  
  // Ingrédients totaux (somme des composants, calculé dynamiquement)
  totalIngredients: [{
    name: String,
    quantity: Number,
    unit: String
  }],
  
  // Nutrition totale (somme des composants)
  totalNutrition: {
    calories: { type: Number, default: 0 },
    proteins: { type: Number, default: 0 }, // en g
    carbs: { type: Number, default: 0 }, // en g
    lipids: { type: Number, default: 0 }, // en g
    fibers: { type: Number, default: 0 }, // en g
    sodium: { type: Number, default: 0 } // en mg
  },
  
  // Temps total (somme des composants)
  totalTime: {
    preparation: { type: Number, default: 0 }, // en minutes
    cooking: { type: Number, default: 0 }, // en minutes
    total: { type: Number, default: 0 } // en minutes
  },
  
  // Restrictions combinées (union de toutes les restrictions)
  allergens: [{ 
    type: String,
    enum: [
      'gluten', 'lactose', 'oeufs', 'arachides', 'fruits_a_coque',
      'soja', 'poisson', 'crustaces', 'mollusques', 'celeri',
      'moutarde', 'sesame', 'sulfites', 'lupin'
    ]
  }],
  
  dietaryRestrictions: [{ type: String }],
  
  // Textures compatibles (intersection des textures des composants)
  textures: [{ 
    type: String,
    enum: ["normale", "tendre", "hachée", "mixée", "moulinée", "lisse", "liquide", "boire"]
  }],
  
  // Adaptation aux établissements
  establishmentTypes: [{ 
    type: String, 
    enum: ["cantine_scolaire", "ehpad", "hopital", "cantine_entreprise", "restaurant"] 
  }],
  
  // Type de repas
  mealType: {
    type: String,
    enum: ['déjeuner', 'dîner', 'petit-déjeuner', 'goûter'],
    default: 'déjeuner'
  },
  
  // Nombre de portions par défaut
  defaultServings: { type: Number, default: 4 },
  
  // Généré automatiquement ou manuellement
  isAutoGenerated: { type: Boolean, default: true },
  
  // Score de qualité (calculé par l'IA)
  qualityScore: { type: Number, default: 0 }, // 0-100
  
  // Tags (hérités des composants + tags spécifiques au template)
  tags: [{ 
    type: String,
    lowercase: true // Normaliser en minuscules pour la recherche
  }],
  // Les tags sont automatiquement combinés depuis les composants
  // + tags spécifiques au template (ex: "combo_populaire", "menu_du_jour")
  
  // Métadonnées
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
});

// Index pour améliorer les performances de recherche
recipeTemplateSchema.index({ protein: 1 });
recipeTemplateSchema.index({ sauce: 1 });
recipeTemplateSchema.index({ accompaniment: 1 });
recipeTemplateSchema.index({ allergens: 1 });
recipeTemplateSchema.index({ dietaryRestrictions: 1 });
recipeTemplateSchema.index({ mealType: 1 });
recipeTemplateSchema.index({ isAutoGenerated: 1 });
recipeTemplateSchema.index({ tags: 1 }); // Index pour recherche par tags
recipeTemplateSchema.index({ createdAt: -1 });

// Middleware pour calculer les totaux avant sauvegarde
recipeTemplateSchema.pre('save', async function(next) {
  try {
    // Populate les composants si nécessaire
    if (!this.populated('protein')) {
      try {
        await this.populate(['protein', 'sauce', 'accompaniment', 'garnish']);
      } catch (populateError) {
        console.error('❌ Erreur lors du populate dans pre-save:', populateError);
        // Continuer quand même, on utilisera les IDs
      }
    }
    
    // Calculer la nutrition totale
    this.totalNutrition = {
      calories: 0,
      proteins: 0,
      carbs: 0,
      lipids: 0,
      fibers: 0,
      sodium: 0
    };
    
    // Calculer les temps totaux
    this.totalTime = {
      preparation: 0,
      cooking: 0,
      total: 0
    };
    
    // Collecter tous les allergènes (union)
    const allAllergens = new Set();
    const allDietaryRestrictions = new Set();
    const allTextures = new Set();
    const allTags = new Set(); // Pour collecter les tags des composants
    
    // Traiter chaque composant
    const components = [this.protein, this.sauce, this.accompaniment, this.garnish].filter(Boolean);
    
    // Vérifier qu'on a au moins la protéine
    if (components.length === 0 || !this.protein) {
      console.error('❌ Aucun composant trouvé dans le template, protéine manquante');
      return next(new Error('Protéine requise pour créer un template'));
    }
    
    for (const component of components) {
      if (component) {
        // Nutrition
        if (component.nutrition) {
          this.totalNutrition.calories += component.nutrition.calories || 0;
          this.totalNutrition.proteins += component.nutrition.proteins || 0;
          this.totalNutrition.carbs += component.nutrition.carbs || 0;
          this.totalNutrition.lipids += component.nutrition.lipids || 0;
          this.totalNutrition.fibers += component.nutrition.fibers || 0;
          this.totalNutrition.sodium += component.nutrition.sodium || 0;
        }
        
        // Temps
        this.totalTime.preparation += component.preparationTime || 0;
        this.totalTime.cooking += component.cookingTime || 0;
        
        // Allergènes
        if (component.allergens) {
          component.allergens.forEach(a => allAllergens.add(a));
        }
        
        // Restrictions alimentaires
        if (component.dietaryRestrictions) {
          component.dietaryRestrictions.forEach(r => allDietaryRestrictions.add(r));
        }
        
        // Textures (intersection - seulement si tous les composants ont la même texture)
        if (component.textures && component.textures.length > 0) {
          if (allTextures.size === 0) {
            component.textures.forEach(t => allTextures.add(t));
          } else {
            // Intersection
            const componentTextures = new Set(component.textures);
            allTextures.forEach(t => {
              if (!componentTextures.has(t)) {
                allTextures.delete(t);
              }
            });
          }
        }
        
        // Collecter les tags (union de tous les tags des composants)
        if (component.tags && component.tags.length > 0) {
          component.tags.forEach(tag => {
            const normalizedTag = tag.toLowerCase().trim();
            if (normalizedTag) {
              allTags.add(normalizedTag);
            }
          });
        }
      }
    }
    
    this.allergens = Array.from(allAllergens);
    this.dietaryRestrictions = Array.from(allDietaryRestrictions);
    this.textures = Array.from(allTextures);
    
    // Ajouter les tags combinés + tags spécifiques au template
    const combinedTags = Array.from(allTags);
    if (this.tags && this.tags.length > 0) {
      // Ajouter les tags spécifiques au template (sans doublons)
      this.tags.forEach(tag => {
        const normalizedTag = tag.toLowerCase().trim();
        if (normalizedTag && !combinedTags.includes(normalizedTag)) {
          combinedTags.push(normalizedTag);
        }
      });
    }
    this.tags = combinedTags;
    
    // Calculer le temps total
    this.totalTime.total = this.totalTime.preparation + this.totalTime.cooking;
    
    // Générer le nom si non fourni (OBLIGATOIRE car required: true)
    if (!this.name || this.name.trim() === '' || this.isNew) {
      try {
        const generatedName = generateTemplateName(components);
        this.name = generatedName || 'Menu modulaire';
      } catch (error) {
        console.error('❌ Erreur lors de la génération du nom:', error);
        // Fallback : créer un nom basique
        const proteinName = this.protein?.name || 'Protéine';
        this.name = `${proteinName} - Menu modulaire`;
      }
    }
    
    // S'assurer que le nom n'est jamais vide
    if (!this.name || this.name.trim() === '') {
      this.name = 'Menu modulaire';
    }
    
    // Générer les instructions combinées
    if (!this.combinedInstructions || !Array.isArray(this.combinedInstructions) || this.combinedInstructions.length === 0) {
      try {
        this.combinedInstructions = combineInstructions(components);
        // S'assurer que c'est un tableau
        if (!Array.isArray(this.combinedInstructions)) {
          this.combinedInstructions = ['Préparer selon les instructions des composants'];
        }
      } catch (error) {
        console.error('❌ Erreur lors de la génération des instructions:', error);
        this.combinedInstructions = ['Préparer selon les instructions des composants'];
      }
    }
    
    // Calculer les ingrédients totaux
    try {
      const servings = this.defaultServings || 4;
      this.totalIngredients = calculateTotalIngredients(components, servings);
    } catch (error) {
      console.error('❌ Erreur lors du calcul des ingrédients:', error);
      this.totalIngredients = [];
    }
    
    this.updatedAt = new Date();
    
    // S'assurer que tous les champs requis sont initialisés
    if (!this.combinedInstructions || !Array.isArray(this.combinedInstructions)) {
      this.combinedInstructions = [];
    }
    if (!this.totalIngredients || !Array.isArray(this.totalIngredients)) {
      this.totalIngredients = [];
    }
    if (!this.allergens || !Array.isArray(this.allergens)) {
      this.allergens = [];
    }
    if (!this.dietaryRestrictions || !Array.isArray(this.dietaryRestrictions)) {
      this.dietaryRestrictions = [];
    }
    if (!this.textures || !Array.isArray(this.textures)) {
      this.textures = [];
    }
    if (!this.tags || !Array.isArray(this.tags)) {
      this.tags = [];
    }
    
    next();
  } catch (error) {
    console.error('❌ Erreur dans le pre-save hook de RecipeTemplate:', error);
    console.error('Stack:', error.stack);
    next(error);
  }
});

// Fonction pour générer le nom du template
function generateTemplateName(components) {
  if (!components || components.length === 0) {
    return 'Menu modulaire';
  }
  const parts = [];
  
  const protein = components.find(c => c && c.type === 'protein');
  const sauce = components.find(c => c && c.type === 'sauce');
  const accompaniment = components.find(c => c && c.type === 'accompaniment');
  const garnish = components.find(c => c && c.type === 'garnish');
  
  if (protein) parts.push(protein.name);
  if (sauce) parts.push(`avec ${sauce.name}`);
  if (accompaniment) parts.push(`et ${accompaniment.name}`);
  if (garnish) parts.push(`+ ${garnish.name}`);
  
  return parts.join(' ');
}

// Fonction pour combiner les instructions
function combineInstructions(components) {
  const instructions = [];
  
  // Instructions de la protéine
  const protein = components.find(c => c && c.type === 'protein');
  if (protein && protein.preparationSteps) {
    instructions.push(...protein.preparationSteps);
  }
  
  // Instructions de la sauce
  const sauce = components.find(c => c && c.type === 'sauce');
  if (sauce && sauce.preparationSteps) {
    instructions.push(`Préparer la ${sauce.name}:`);
    instructions.push(...sauce.preparationSteps);
  }
  
  // Instructions de l'accompagnement
  const accompaniment = components.find(c => c && c.type === 'accompaniment');
  if (accompaniment && accompaniment.preparationSteps) {
    instructions.push(`Préparer ${accompaniment.name}:`);
    instructions.push(...accompaniment.preparationSteps);
  }
  
  return instructions;
}

// Fonction pour calculer les ingrédients totaux
function calculateTotalIngredients(components, servings) {
  const ingredientsMap = new Map();
  
  for (const component of components) {
    if (component && component.ingredients) {
      for (const ing of component.ingredients) {
        const key = `${ing.name}-${ing.unit}`;
        if (ingredientsMap.has(key)) {
          const existing = ingredientsMap.get(key);
          existing.quantity += ing.quantity * servings;
        } else {
          ingredientsMap.set(key, {
            name: ing.name,
            quantity: ing.quantity * servings,
            unit: ing.unit
          });
        }
      }
    }
  }
  
  return Array.from(ingredientsMap.values());
}

// Méthode pour calculer les ingrédients pour un nombre de personnes spécifique
recipeTemplateSchema.methods.getIngredientsForServings = function(servings) {
  const multiplier = servings / (this.defaultServings || 4);
  return this.totalIngredients.map(ing => ({
    name: ing.name,
    quantity: ing.quantity * multiplier,
    unit: ing.unit
  }));
};

const RecipeTemplate = mongoose.model("RecipeTemplate", recipeTemplateSchema);
export default RecipeTemplate;

